// Generated by CoffeeScript 1.7.1
(function() {
  var CardViewModel, EstimateViewModel, PlanningPokerViewModel, SessionViewModel,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  PlanningPokerViewModel = (function() {
    function PlanningPokerViewModel() {
      var firstSplit, session, _i, _len, _ref;
      this.planningPokerSessions = ko.observableArray([]);
      this.requirements = [];
      this.team = [];
      this.decks = [];
      this.activeSession = ko.observable();
      firstSplit = window.location.search.split('&');
      if (firstSplit.length > 1) {
        this.username = firstSplit[0].split('=')[1];
        this.querySession = firstSplit[1].split('=')[1];
      } else {
        this.username = window.location.search.split('=')[1];
      }
      $.ajax({
        dataType: 'json',
        url: 'API/requirementmanager/requirement',
        async: false,
        success: (function(_this) {
          return function(data) {
            var requirement, _i, _len;
            for (_i = 0, _len = data.length; _i < _len; _i++) {
              requirement = data[_i];
              requirement['voteValue'] = 0;
            }
            return _this.requirements = data;
          };
        })(this)
      });
      $.ajax({
        dataType: 'json',
        url: 'API/planningpoker/deck',
        async: false,
        success: (function(_this) {
          return function(data) {
            return _this.decks = data;
          };
        })(this)
      });
      $.ajax({
        dataType: 'json',
        url: 'API/core/user',
        async: false,
        success: (function(_this) {
          return function(data) {
            var user, _i, _len, _ref, _results;
            _results = [];
            for (_i = 0, _len = data.length; _i < _len; _i++) {
              user = data[_i];
              if (_ref = user['username'], __indexOf.call(_this.team, _ref) < 0) {
                _results.push(_this.team.push(user['username']));
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          };
        })(this)
      });
      this.params = {
        requirements: this.requirements,
        team: this.team,
        username: this.username,
        decks: this.decks
      };
      $.ajax({
        dataType: 'json',
        url: 'API/planningpoker/planningpokersession',
        async: false,
        success: (function(_this) {
          return function(data) {
            var session, _i, _len, _results;
            _results = [];
            for (_i = 0, _len = data.length; _i < _len; _i++) {
              session = data[_i];
              _results.push(_this.planningPokerSessions.push(new SessionViewModel(session, _this.params)));
            }
            return _results;
          };
        })(this)
      });
      this.openSessions = ko.computed((function(_this) {
        return function() {
          return _this.planningPokerSessions().filter(function(session) {
            return session.gameState() === 'OPEN';
          });
        };
      })(this));
      this.setActiveSession = (function(_this) {
        return function(session) {
          return _this.activeSession(session);
        };
      })(this);
      this.checkForUpdates = (function(_this) {
        return function() {
          return $.ajax({
            dataType: 'json',
            url: 'API/requirementmanager/requirement',
            success: function(data) {
              var requirement, _i, _len;
              for (_i = 0, _len = data.length; _i < _len; _i++) {
                requirement = data[_i];
                requirement['voteValue'] = 0;
              }
              _this.requirements = data;
              _this.params.requirements = data;
              return $.ajax({
                dataType: 'json',
                url: 'API/planningpoker/deck',
                success: function(data) {
                  _this.decks = data;
                  _this.params.decks = data;
                  return $.ajax({
                    type: 'GET',
                    dataType: 'json',
                    url: 'API/Advanced/planningpoker/planningpokersession/check-for-updates',
                    success: _this.applyUpdates
                  });
                }
              });
            }
          });
        };
      })(this);
      this.applyUpdates = (function(_this) {
        return function(updates) {
          var changedSession, newSession, session, _i, _j, _len, _len1, _ref, _results;
          _results = [];
          for (_i = 0, _len = updates.length; _i < _len; _i++) {
            changedSession = updates[_i];
            newSession = true;
            _ref = _this.planningPokerSessions();
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              session = _ref[_j];
              if (changedSession['uuid'] === session.uuid()) {
                newSession = false;
                session.applyUpdate(changedSession);
              }
            }
            if (newSession) {
              _results.push(_this.planningPokerSessions.push(new SessionViewModel(changedSession, _this.params)));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
      })(this);
      setInterval(this.checkForUpdates, 5000);
      if (this.querySession) {
        _ref = this.planningPokerSessions();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          session = _ref[_i];
          if (this.querySession === session.uuid()) {
            this.activeSession(session);
          }
        }
      }
    }

    return PlanningPokerViewModel;

  })();

  SessionViewModel = (function() {
    function SessionViewModel(data, params) {
      var deck, estimate, field, requirement, userEstimate, value, voterList, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      this.parent = parent;
      this.allRequirements = ko.observableArray(params.requirements);
      this.team = ko.observableArray(params.team);
      this.username = params.username;
      this.params = params;
      for (field in data) {
        value = data[field];
        this[field] = ko.observable(value);
      }
      _ref = this.params.decks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        deck = _ref[_i];
        if (deck['id'] === this.sessionDeckID()) {
          this.sessionDeck = ko.observable(deck);
        }
      }
      this.params = params;
      this.params['usingDeck'] = this.isUsingDeck();
      this.params['deck'] = {};
      if (this.isUsingDeck()) {
        this.params['deck'] = this.sessionDeck();
      }
      this.requirementEstimates = ko.observableArray([]);
      _ref1 = this.allRequirements();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        requirement = _ref1[_j];
        if (_ref2 = requirement['id'], __indexOf.call(this.requirementIDs(), _ref2) >= 0) {
          userEstimate = {
            sessionID: this.uuid(),
            requirementID: requirement['id'],
            ownerName: this.username,
            vote: 0
          };
          voterList = [];
          _ref3 = this.estimates();
          for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
            estimate = _ref3[_k];
            if (estimate['requirementID'] === requirement['id']) {
              if (estimate['vote'] > -1) {
                voterList.push(estimate['ownerName']);
              }
              if (estimate['ownerName'] === this.username) {
                userEstimate['vote'] = estimate['vote'];
              }
            }
          }
          this.requirementEstimates.push(new EstimateViewModel(userEstimate, voterList, requirement, this.params));
        }
      }
      this.requirements = ko.computed((function(_this) {
        return function() {
          var result, _l, _len3, _ref4, _ref5;
          result = [];
          _ref4 = _this.allRequirements();
          for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
            requirement = _ref4[_l];
            if (_ref5 = requirement['id'], __indexOf.call(_this.requirementIDs(), _ref5) >= 0) {
              result.push(requirement);
            }
          }
          return result;
        };
      })(this));
      this.applyUpdate = (function(_this) {
        return function(update) {
          var changedEstimate, requirementEstimate, _l, _len3, _ref4, _results;
          _ref4 = update['estimates'];
          _results = [];
          for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
            changedEstimate = _ref4[_l];
            _results.push((function() {
              var _len4, _m, _ref5, _results1;
              _ref5 = this.requirementEstimates();
              _results1 = [];
              for (_m = 0, _len4 = _ref5.length; _m < _len4; _m++) {
                requirementEstimate = _ref5[_m];
                if (changedEstimate['requirementID'] === requirementEstimate.requirement()['id']) {
                  _results1.push(requirementEstimate.applyUpdate(changedEstimate));
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
            }).call(_this));
          }
          return _results;
        };
      })(this);
    }

    return SessionViewModel;

  })();

  EstimateViewModel = (function() {
    function EstimateViewModel(userEstimate, voterList, req, params) {
      var cardValue, key, observableEstimate, value, _i, _len, _ref;
      this.requirement = ko.observable(req);
      this.requirements = ko.observable(params.requirements);
      this.team = ko.observable(params.team);
      this.usingDeck = ko.observable(params.usingDeck);
      this.deck = ko.observable(params.deck);
      this.username = params.username;
      this.voted = ko.observableArray(voterList);
      this.showSuccessMessage = ko.observable(false);
      this.voteValue = ko.observable(0).extend({
        required: {
          message: 'Please enter a vote!'
        },
        pattern: {
          message: 'Please enter a positive integer!',
          params: '^\\d+$'
        }
      });
      observableEstimate = {};
      for (key in userEstimate) {
        value = userEstimate[key];
        observableEstimate[key] = ko.observable(value);
      }
      this.estimate = ko.observable(observableEstimate);
      if (this.usingDeck()) {
        this.cards = ko.observableArray([]);
        _ref = this.deck().numbersInDeck;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cardValue = _ref[_i];
          this.cards.push(new CardViewModel(cardValue, false, this));
        }
      }
      this.widthPercent = ko.computed((function(_this) {
        return function() {
          var numVotes, percent, teamSize;
          numVotes = _this.voted().length;
          teamSize = _this.team().length;
          percent = 0;
          if (teamSize > 0) {
            percent = parseInt((numVotes / teamSize) * 100);
          }
          return "" + percent + "%";
        };
      })(this));
      this.totalValue = ko.computed((function(_this) {
        return function() {
          var card, total, _j, _len1, _ref1;
          if (_this.usingDeck()) {
            total = 0;
            _ref1 = _this.cards();
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              card = _ref1[_j];
              if (card.selected()) {
                total += card.value();
              }
            }
            return total;
          } else {
            return _this.voteValue();
          }
        };
      })(this));
      this.setVoteValue = (function(_this) {
        return function(value) {
          var card, deckNumbers, remaining, selectedCards, _j, _k, _len1, _len2, _ref1, _ref2, _results;
          if (_this.usingDeck()) {
            deckNumbers = _this.deck().numbersInDeck.slice(0);
            deckNumbers = deckNumbers.sort().reverse();
            selectedCards = [];
            remaining = value;
            for (_j = 0, _len1 = deckNumbers.length; _j < _len1; _j++) {
              cardValue = deckNumbers[_j];
              if (remaining >= cardValue) {
                selectedCards.push(cardValue);
                remaining -= cardValue;
              }
            }
            _ref1 = _this.cards();
            _results = [];
            for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
              card = _ref1[_k];
              if (_ref2 = card.value(), __indexOf.call(selectedCards, _ref2) >= 0) {
                if (card.value() > 0) {
                  _results.push(card.selected(true));
                } else {
                  _results.push(void 0);
                }
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          } else {
            return _this.voteValue(value);
          }
        };
      })(this);
      this.setVoteValue(this.estimate().vote());
      this.notifySelection = (function(_this) {
        return function(cardViewModel) {
          var card, _j, _len1, _ref1;
          if (!_this.deck().allowMultipleSelections) {
            _ref1 = _this.cards();
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              card = _ref1[_j];
              card.selected(false);
            }
            return cardViewModel.selected(true);
          }
        };
      })(this);
      this.submitVote = (function(_this) {
        return function() {
          if (!_this.voteValue.error()) {
            _this.estimate().vote(parseInt(_this.totalValue()));
            return $.ajax({
              type: 'POST',
              dataType: 'json',
              url: 'API/Advanced/planningpoker/planningpokersession/update-estimate-website',
              data: ko.toJSON(_this.estimate()),
              success: function(data) {
                var _ref1;
                if (_ref1 = _this.username, __indexOf.call(_this.voted(), _ref1) < 0) {
                  _this.voted.push(_this.username);
                }
                _this.showSuccessMessage(true);
                return setTimeout((function() {
                  return _this.showSuccessMessage(false);
                }), 2000);
              }
            });
          }
        };
      })(this);
      this.applyUpdate = (function(_this) {
        return function(update) {
          var _ref1;
          if (_ref1 = update['ownerName'], __indexOf.call(_this.voted(), _ref1) < 0) {
            if (update['vote'] > -1) {
              return _this.voted.push(update['ownerName']);
            }
          }
        };
      })(this);
      this.voteError = ko.computed((function(_this) {
        return function() {
          var vote;
          vote = _this.voteValue();
          return _this.voteValue.error() !== null;
        };
      })(this));
    }

    return EstimateViewModel;

  })();

  CardViewModel = (function() {
    function CardViewModel(value, selected, parentViewModel) {
      this.value = ko.observable(value);
      this.selected = ko.observable(selected);
      this.parent = parentViewModel;
      this.cardClicked = (function(_this) {
        return function() {
          if (_this.selected()) {
            return _this.selected(false);
          } else {
            _this.selected(true);
            return _this.parent.notifySelection(_this);
          }
        };
      })(this);
    }

    return CardViewModel;

  })();

  $(function() {
    ko.bindingHandlers.fadeVisible = {
      init: function(element, valueAccessor) {
        var value;
        value = valueAccessor();
        return $(element).toggle(ko.utils.unwrapObservable(value));
      },
      update: function(element, valueAccessor) {
        var value;
        value = valueAccessor();
        if (ko.utils.unwrapObservable(value)) {
          return $(element).fadeIn('fast');
        } else {
          return $(element).fadeOut('fast');
        }
      }
    };
    window.PokerVM = new PlanningPokerViewModel();
    return ko.applyBindings(window.PokerVM);
  });

}).call(this);
